\section{Introduction}
Parallelism and cotenancy are the future. However, people program as though there is no cotenancy. This causes performance problems. Today, people statically partition. Utilization is not great and you don't get perfect isolation anyway.
\subsection*{Parallelism and cotenancy are here to stay}
\begin{itemize}
  \item Increasing number of cores \cite{baumann2009multikernel}
  \item As a result, application developers must think about parallelism to get performance
  \item Cloud becoming increasingly popular; run many containers / VMs on a single host and want performance guarantees for tenants (sophisticated orchestration / scheduling)
\end{itemize}
\subsection*{Developers / OS have digested parallelism, but not cotenancy}
\begin{itemize}
  \item Developers: assume have full machine (over-provision) because not easy to know what resources we have.
  \item OS: schedule individual threads (Linux). Some control with cgroups to coordinate groups of threads. (is this fair? probably should write a different way. Don't want to offend OS people by implying OS can't handle multiuser...)
\end{itemize}
\subsection*{This can lead to poor utilization or excessive resource contention}
\begin{itemize}
  \item Over-provisioning may low utilization on many core. CPU share and quota (cgroup) not enough; need to change parallelism of applications to affect utilization
  \item Without coordinating resource usage, system may thrash
  \item [TODO: INSERT SMALL EXAMPLE] since different applications have different overheads / slow-down in total CPU time
\end{itemize}
\subsection*{Contributions}
\begin{itemize}
  \item Observe that dynamically scaling parallelism can improve system performance (throughput, latency)
  \item Thread library that can dynamically scale application parallelism
  \item User-level coordinator to determine appropriate level of parallelism for registered applications
\end{itemize}
