\section{The case for cooperative resource sharing}

\input{fig/ars.tex}

Given challenges observed in the previous section, we advocate an extension to the traditional application-OS abstractions with a dynamic, bi-directional communication mechanism between applications and the OS scheduler, as shown in Figure 4. 

As long as applications are architected with the assumption that they have exclusive access to machine resources, resource contention is inevitable in parallel, multi-tenant environments. Developers will be required to over-provision compute capacity in order to avoid resource contention, and otherwise program and plan with the expectation that they are sharing a machine with others. They will not be fooled by the illusion that they the sole users of the system.

We argue for cooperative resource sharing as a preferable multi-tasking paradigm. In this scheme, applications are written with the full knowledge that they are co-tenants sharing resources, and agree to allow a centralized scheduler to control their resource consumption. We propose \mechfull{}s as a potential mechanism to implement cooperative resource sharing.

\subsection{Cooperative resource sharing may uniquely overcome resource contention problems}
When applications cooperate, they receive structured information about "real" system resources and instructions about how to utilize resources for greatest effect. In any system where isolation is a core guarantee, this information is by definition unavailable to the application.

Attempts to solve resource contention problems by strengthening isolation guarantees ultimately run up against this limitation. Slicing applications through virtualization does not change fundamental hardware facts (see Figure 3). 

\subsection{Modern cloud computing environments can limit the downsides of cooperation}
The fundamental flaw in cooperative multitasking schemes is that they rely on individual applications to behave themselves. A single bad actor in the system can monopolize resources, which creates a prisoner's dilemma where it is simpler for the scheduler to pre-empt tasks to ensure fairness.

However, in today's managed compute environments, all non-trivial applications running on a server are under the full control of the service's operator. For example, a multi-tenant database-as-a-service like Amazon's DynamoDB \cite{decandia2007dynamo} will consist of multiple tenants, all running proprietary Amazon code. In such an environment, ensuring that all applications "play by the rules" is simply a matter of integrating some mechanism like an \mech{} into the application code.

\subsection{What are scenarios under which we might use \mech{}s?}
In general, any environment that requires multitasking over several highly parallel applications could benefit from cooperative resource sharing. Some examples include:
\begin{itemize}
    \item \textbf{OLAP and batch processing workloads.} For big data analytics and data warehousing applications, many highly parallel jobs may be placed a single node. The application itself can be modified to cooperate with the \mech{}, and the interest of the service owner is likely to maximize global throughput per node.
    \item \textbf{Proprietary compute clouds.} Many companies operate private clouds, where all users and applications are under 
\end{itemize}
